# Artisan Console

فن هو أداة CLI التي تأتي مع غورافيل للتفاعل مع سطر الأوامر. يمكنك الوصول إليه باستخدام
`facades.Artisan()`. هذه الأداة لديها عدة أوامر مفيدة يمكن أن تساعدك في تطوير تطبيقك.
استخدم الأمر التالي لعرض جميع الأوامر المتاحة.

```shell
قم بتشغيل. قائمة الحرفيين
```

ولكل أمر أيضا ميزة "مساعدة" تعرض وتشرح الحجج والخيارات المرتبطة بالقيادة. إلى
راجع شاشة المساعدة، فقط أضف "مساعدة" قبل اسم الأمر.

```shell
قم بتشغيل. المساعدة الحرفية في الترحيل
```

عوضا عن تكرار `إذهب للتشغيل'. حرفي ...` أمر ، قد ترغب في إضافة اسم مستعار إلى تكوين قذيفة الخاص بك مع الأمر الطرفي
أدناه:

```shell
صدى -e "\r\nالاسم الحرفي المستعار =\"إذهب إلى تشغيل الحرفيين\"" >>~/.zshrc
```

ثم يمكنك ببساطة تشغيل الأوامر الخاصة بك مثل هذا:

```shell
مصنع حرفي:controller DemoController
```

يمكنك أيضًا استخدام نص قذيفة "حرفي" مثل هذا:

```shell
./حرفي صنع:controller DemoController
```

### توليد الأوامر

يمكنك استخدام الأمر 'make:command' لإنشاء أمر جديد في دليل 'app/console/commands'. لا تقلق إذا كان
هذا الدليل غير موجود في التطبيق الخاص بك، فسيتم إنشاؤه لأول مرة تقوم بتشغيل الأمر \`make:command':

```shell
قم بتشغيل. مارست الحرفية:command SendEmails
تشغيل. مارست الحرفية:command user/SendEmails
```

### هيكل الأوامر

بعد إنشاء الأمر الخاص بك، تعيين قيم مناسبة لخصائص التوقيع والوصف للبناء. سيتم استدعاء طريقة
'Handle' عند تنفيذ الأمر الخاص بك. تحتاج إلى تطبيق منطقك في هذه الطريقة.

```go
أوامر الحزمة

استيراد (
  "github.com/goravel/framework/contracts/console"
  "github. om/goravel/framework/contracts/console/command"


نوع SendEmails struct {


// Signature اسم وتوقيع أمر وحدة التحكم.
func (المتلقي *SendEmails) Signature() string {
  return "send:emails"
}

// وصف وصف أمر وحدة التحكم.
func (المتلقي *SendEmails) Description() string {
  العودة "إرسال رسائل البريد الإلكتروني"


// توسيع نطاق أمر وحدة التحكم
Fc (المتلقي *SendEmails) Extend(). xtend {
  Recommand.Extend{}
}

// Handle Execute the consle.
مربع (متلقي *SendEmails) Handle(ctx console.Context) الخطأ {
  return nil
}
```

## الأمر I/O

### Retrieving Input

عند كتابة أوامر وحدة التحكم ، من المعتاد جمع مدخلات المستخدم من خلال 'حجج` أو 'خيارات`. With Goravel, it's
extremely easy to retrieve the arguments and options that the user provides.

#### حجج

اتبع الحجج بعد الأمر:

```shell
تشغيل . حرفي يرسل :emails NAME EMAIL
```

Get arguments:

```go
Fc (المتلقى*SendEmails) Handle(ctx console.Context) خطأ {
  اسم := ctx.Argument(0)
  البريد الإلكتروني := ctx.Argument(1)
  كل := ctx.Arguments()

  العودة صفر
}
```

#### خيارات

الخيارات، مثل الحجج، شكل آخر من مدخلات المستخدم. يتم تثبيت الخيارات مسبقاً بواسطة وصلتين (--) عندما يتم توفيرهما
عبر سطر الأوامر.

التعريف：

```go
func (receiver *ListCommand) Extend() command.Extend {
  return command.Extend{
    Flags: []command.Flag{
      &command.StringFlag{
        Name:    "lang",
        Value:   "default",
        Aliases: []string{"l"},
        Usage:   "language for the greeting",
      },
    },
  }
}
```

احصل على：

```go
مربع (الاستلام *Listcommand) Handle(ctx console.Context) الخطأ {
  lang := ctx.Option("lang")

  العودة صفر
}
```

استخدام：

```shell
go run . artisan emails --lang Chinese
go run . artisan emails -l Chinese
```

إشعار: عند استخدام الحجج والخيارات، حدد الخيارات قبل الحجج. مثال:

```shell
// يمين
قيد التشغيل. يتم تشغيل رسائل البريد الإلكتروني الحرفية --lang=Chinname
/ / / خطأ
. يتم تشغيل رسائل البريد الإلكتروني الحرفية --lang=الإسم الصيني
```

باستثناء `command.StringFlag`، يمكننا أيضا استخدام نوع آخر من `Flag` و `Option*`: `StringSliceFlag`، `BoolFlag`،
`Float64Flag`، `Float64SliceFlag`، `IntFlag`، `IntSliceFlag`، `Int64Flag`، `Int64Flag`.

### الدعوة إلى الإدخال

#### طرح الأسئلة

بالإضافة إلى الحجج والخيارات، يمكنك أيضًا توجيه المستخدم للحصول على مدخلات أثناء تنفيذ الأمر. طريقة
`Ask` سوف تدفع المستخدم بالسؤال المعين وتعيد إجابتهم:

```go
مربع (تلقي *SendEmails) Handle(ctx console.Context) خطأ {
  البريد الإلكتروني، الخطأ := ctx.Ask("ما هو عنوان البريد الإلكتروني الخاص بك؟")
  
  Reerr
}
```

بالإضافة إلى ذلك، يمكنك تمرير الخيارات إلى طريقة "Ask" كحجة ثانية اختيارية:

```go
مربع (متلقي *SendEmails) Handle(ctx console.Context) خطأ {
    name, err := ctx.Ask("ما هو اسمك؟", console. اختيار{
        الافتراضي: "كريشان"،
    })
    
    Reerr


// الخيارات المتاحة
نوع AskOption struct {
    // الإفتراضي القيمة الافتراضية للمدخل.
    السلسلة الإفتراضية
    // وصف وصف الإدخال.
    وصف المقطع
    // سطر عدد الأسطر للمدخل. استخدم لنص سطور متعددة)
    خطوط int
    // حدد حد الحرف للمدخل.
    الحدّ int
    // متعددة يحدد ما إذا كان الإدخال سطر واحد أو سطر متعدد أسطر
    سطر متعدد
    // مكان حامل الإدخال.
    السلسلة
    // توجيه رسالة الفور. استخدام لمدخل سطر واحد)
    سلسلة فورية
    // التحقق من وظيفة المصادقة على الإدخال.
    التحقق من صحة الدالة (سلسلة) الخطأ
}
```

قد تحتاج في بعض الأحيان إلى إخفاء إدخال المستخدم، مثل عند المطالبة بكلمة مرور. يمكنك استخدام طريقة "سرية" ل
إخفاء مدخلات المستخدم:

```go
func (receiver *SendEmails) Handle(ctx console.Context) error {
    password, err := ctx.Secret("What is the password?", console.SecretOption{
        Validate: func (s string) error {
            if len(s) < 8 {
                return errors.New("password length should be at least 8")
            }
            return nil
        },
    })
    
    return err
}

// Available options
type SecretOption struct {
    // Default the default value for the input.
    Default string
    // Description the input description.
    Description string
    // Limit the character limit for the input.
    Limit int
    // Placeholder the input placeholder.
    Placeholder string
    // Validate the input validation function.
    Validate func(string) error
}
```

#### تأكيد الإجراءات

إذا كنت بحاجة إلى أن تطلب من المستخدم تأكيد إجراء ما قبل المتابعة، فيمكنك استخدام طريقة "تأكيد". بشكل افتراضي، هذه الطريقة
سوف ترجع "خطأ" ما لم يختار المستخدم الخيار الإيجابي.

```go
إذا كان الجواب ، _ := ctx.Confirm("هل ترغب في المتابعة؟")؛ !الرد {
    // ...
}
```

يمكنك أيضًا تمرير حجة ثانية إلى طريقة "تأكيد" لتخصيص القيمة الافتراضية، وتسمية الأزرار الايجابية و
السالبة:

```go
إذا كان الجواب ، _ := ctx.Confirm("هل ترغب في المتابعة؟"، وحدة التحكم. تثبيت الخيار! الرد {
 Defaul: true,
 Affirirative : "نعم",
 السالب: "لا"،
}) {
    // . .
}

// الخيارات المتاحة
نوع ConfirmOption struct {
    // الإيجابي تسمية الزر الايجابي.
    سلسلة إيجابية
    // الافتراضي القيمة الافتراضية للمدخل.
    الافتراضي
    // وصف وصف الإدخال.
    وصف المقطع
    / / تسمية سلبية للزر السالب.
    السلسلة السلبية
}
```

#### أسئلة مختارة منفردة

إذا كنت بحاجة إلى أن تطلب من المستخدم تحديد خيار من قائمة الخيارات، فيمكنك استخدام طريقة "الاختيار". طريقة "الاختيار"
سوف تعيد قيمة الخيار المحدد:

```go
السؤال := "ما هي لغة البرمجة المفضلة لديك؟"
خيارات := []console. hoice{
    {Key: "go", Vvalue: "Go"},
    {المفتاح: "php", Vvalue: "PHP"},
    {Key: "python", القيمة: "Python"},
    {المفتاح: "cpp", القيمة: "C++", محدد: true},
}
لون الخطأ := ctx. hoice(سؤال، خيارات)
```

بالإضافة إلى ذلك، يمكنك تمرير الخيارات إلى طريقة "الاختيار" كحجة ثانية اختيارية:

```go
السؤال := "ما هي لغة البرمجة المفضلة لديك؟"
خيارات := []console. hoice{
    {Key: "go", Vvalue: "Go"},
    {المفتاح: "php", Vvalue: "PHP"},
    {Key: "python", القيمة: "Python"},
    {المفتاح: "cpp", القيمة: "C++", محدد: true},
}

لون الخطأ := ctx. hoice(سؤال، خيارات، وحدة التحكم. hoiceOption{
    الافتراضي: "go",
})

// الخيارات المتاحة
نوع ChoiceOption struct {
    // الافتراضي القيمة الافتراضية للمدخل.
    السلسلة الافتراضية
    // وصف وصف الإدخال.
    وصف السلسلة
    // المصادقة على وظيفة المصادقة على الإدخال.
    التحقق من صحة الدالة (السلسلة) خطأ
}
```

#### أسئلة متعددة مختارة

إذا كنت بحاجة إلى أن تطلب من المستخدم تحديد خيارات متعددة من قائمة الخيارات، فيمكنك استخدام طريقة 'MultiSelect'. طريقة
`MultiSelect` سوف تعيد قيم الخيارات المحددة:

```go
السؤال := "ما هي لغات البرمجة المفضلة لديك؟"
خيارات := []console. hoice{
    {Key: "go", Vvalue: "Go"},
    {المفتاح: "php", Vvalue: "PHP"},
    {Key: "python", القيمة: "Python"},
    {المفتاح: "cpp", القيمة: "C++", محدد: true},
}
الألوان, err := ctx. ultiSelect(سؤال، خيارات)
```

بالإضافة إلى ذلك، يمكنك تمرير الخيارات إلى طريقة "MultiSelect" كحجة ثانية اختيارية:

```go
السؤال := "ما هي لغات البرمجة المفضلة لديك؟"
خيارات := []console. hoice{
    {Key: "go", Vvalue: "Go"},
    {المفتاح: "php", Vvalue: "PHP"},
    {Key: "python", القيمة: "Python"},
    {المفتاح: "cpp", القيمة: "C++", محدد: true},
}

الألوان, err := ctx. ultiSelect(سؤال، خيارات، وحدة التحكم. ultiSelectOption{
    الافتراضي: []سلسلة{"go", "php"},
})

// الخيارات المتاحة
نوع MultiSelectOption struct {
    // الافتراضي القيمة الافتراضية للمدخل.
    الافتراضي []المقطع
    // وصف وصف المدخلات.
    الوصف المقطع
    // يحدد ما إذا كان من الممكن تصفية الخيارات، اكتب `/` لبدء الفلتر.
    قابلة للتصفية
    // تحديد عدد الخيارات التي يمكن اختيارها.
    الحد من الإشارة
    // التحقق من وظيفة المصادقة على الإدخال.
    التحقق من وظيفة ([]سلة) خطأ
}
```

### كتابة المخرجات

قد تحتاج في بعض الأحيان إلى كتابة الإخراج إلى وحدة التحكم. يوفر Goravel عدة طرق لمساعدتك في كتابة المخرجات
إلى وحدة التحكم. ولكل طريقة من هذه الطرق ناتجها المناسب الملون. على سبيل المثال، "خطأ" سيعرض النص
باللون الأحمر.

```go
تمويل (متلقي *SendEmails) Handle(ctx console.Context) خطأ {
  ctx. حذف ("هذه رسالة تعليق")
  ctx.Info("هذه رسالة معلومات")
  ctx. rror("هذه رسالة خطأ")
  ctx.Line("هذه رسالة سطر")
  ctx. arning("هذه رسالة تحذير")
  refl
}
```

يمكنك استخدام طريقة "NewLine" لكتابة سطر جديد إلى وحدة التحكم:

```go
// كتابة سطر فارغ واحد
ctx.NewLine()

// كتابة سطر فارغ متعدد
ctx.NewLine(2)
```

#### شريط التقدم

للمهام التي تستغرق وقتاً طويلاً، غالباً ما يكون من المفيد تزويد المستخدم ببعض الإشارات إلى مقدار الوقت الذي ستتخذه المهمة
. يمكنك استخدام طريقة 'سحب التقدم' لعرض شريط التقدم.

```go
البنود := []any{"item1", "item2", "item3"}
_, err := ctx.WithProgressBar(items, func(البند any) خطأ {
    // performTask(item)
    Renl
})
```

قد تحتاج أحيانا إلى تحديث شريط التقدم يدويا. يمكنك استخدام طريقة "إنشاء تقدم" لتحديث شريط التقدم
:

```go
المستخدمون := []سلسلة{"user1", "user2", "user3"}
شريط := ctx.CreateProgressBar(len(users))

err := bar. tart()

لـ _، المستخدم := نطاق المستخدمين {
    // معالجة المستخدم
    شريط الرقص()
 
 // نوم لفترة لمحاكاة المعالجة 
    مرة. النوم (time.Millisecond * 50)
}

err = bar.Finish()
```

#### دباعي

إذا كنت بحاجة إلى عرض دبوس أثناء تشغيل مهمة، فيمكنك استخدام طريقة "سبينر".

```go
err := ctx.Spinner("التحميل...", console. خيار pinnerOption{
    الإجراء: وظيفة () خطأ {
        // متى توقف الدوران
        وقت. النوم (2 * time.Second)
        refl
    },
})
```

## الفئة

يمكنك تعيين مجموعة من الأوامر إلى نفس الفئة، تكون مناسبة في `تشغيل'. قائمة حرفية`:

```go
// توسيع نطاق أمر وحدة التحكم ممتد.
func (المتلقي *ConsoleMakecommand) Extend() command.Exend {
  Recommand.Extend{
    categorory: "make",
  }
}
```

## أوامر التسجيل

يجب تسجيل جميع أوامر وحدة التحكم الخاصة بك ضمن دالة "الأوامر" في "app\console\kernel.go\`.

```go
مالك أوامر (kernel Kernel) الأوامر() []console.Command {
  العودة []console.command{
    &commands.SendEmails{},
  }
}
```

## تنفيذ أوامر البرمجة

في بعض الأحيان قد ترغب في تنفيذ أمر حرفي خارج CLI، يمكنك استخدام طريقة "الاتصال" على
'واجهات الأمور. rtisan()\` لتشغيل هذا.

```go
facades.Route().Get("/", func(c *gin.Context) {
  facades.Artisan().Call("رسائل البريد الإلكتروني")
  facades.Artisan().Call("رسائل البريد الإلكتروني - لانغ الاسم الصيني") // / مع الحجج والخيارات
})
```
