# مخبئ

يوفر Goravel وحدة ذاكرة التخزين المؤقت القابلة للتمديد والتي يمكن تشغيلها باستخدام `facades.Cache()`. Goravel يأتي مع سائق 'memory'
، للسائقين الآخرين ، يرجى التحقق من حزم الملحق المستقلة المقابلة:

| سائق  | رابط                                                                                                 |
| ----- | ---------------------------------------------------------------------------------------------------- |
| ريديس | [https://github.com/goravel/redis](https://github.com/goravel/redis) |

## الإعدادات

اصنع كل الاعدادات المخصصة في `config/cache.go`.

## استخدام ذاكرة التخزين المؤقت

### حقن السياق

```go
facades.Cache().WithContext(ctx)
```

### الوصول إلى مخازن التخزين المؤقت المتعددة

يمكنك الوصول إلى مختلف مخازن التخزين المؤقت عن طريق طريقة "المتجر". المفتاح الذي تم تمريره إلى طريقة "المتجر" يجب أن يتوافق مع
أحد المتاجر المدرجة في مصفوفة تكوين "المتاجر" في ملف إعدادات التخزين المؤقت الخاص بك:

```go
القيمة := facades.Cache().Store("redis").Get("foo")
```

### استرداد العناصر من ذاكرة التخزين المؤقت

```go
القيمة := facades.Cache().Get("goravel", "default")
قيمة := facades.Cache().GetBool("goravel", true)
قيمة := facades.Cache().GetInt("goravel", 1)
قيمة := facades.Cache().GetString("goravel", "default")
```

يمكنك تمرير "وظيفة" كقيمة افتراضية. إذا كانت البيانات المحددة غير موجودة في ذاكرة التخزين المؤقت، فإن نتيجة 'func` سيتم إرجاعها
 طريقة الإغلاق الانتقالي تسمح لك بالحصول على القيم الافتراضية من قاعدة البيانات أو الخدمات الخارجية
الأخرى. لاحظ هيكل الإغلاق 'func() any`.

```go
القيمة := facades.Cache().Get("goravel", func() أي {
    العودة "default"
})
```

### التحقق من وجود العنصر

```go
bool := facades.Cache().Has("goravel")
```

### زيادة / تقليل القيم

يمكن استخدام طريقتي "زيادة" و "مراسيم" لضبط قيمة العناصر الصحيحة في ذاكرة التخزين المؤقت. كلا الطريقتين
تقبل حجة ثانية اختيارية تشير إلى المبلغ الذي يمكن بواسطته زيادة قيمة العنصر أو تخفيضه:

```go
facades.Cache().زيادة ("المفتاح")
facades.Cache().زيادة ("المفتاح")
facades.Cache().Decrement("المفتاح")
facades.Cache().Decrement("المفتاح"، الكمية)
```

### استرداد و تخزين

في بعض الأحيان قد ترغب في الحصول على بيانات من ذاكرة التخزين المؤقت، وعندما لا يوجد عنصر ذاكرة التخزين المؤقت المطلوب. يمكن للبرنامج
تخزين قيمة افتراضية لك.

```go
قيمة, err := facades.Cache().Remember("goravel", 5*time.II, func() (أي خطأ) {
    العودة "goravel", nl
})
```

إذا كانت البيانات التي تريدها غير موجودة في ذاكرة التخزين المؤقت، سيتم تنفيذ الإغلاق الذي تم تمريره إلى طريقة "تذكير"، ثم
سيتم إرجاع النتيجة ووضعها في ذاكرة التخزين المؤقت.

يمكنك استخدام طريقة "تذكر الأبد" لاسترداد البيانات من ذاكرة التخزين المؤقت أو تخزينها بشكل دائم:

```go
قيمة, err := facades.Cache().RememberForever("goravel", func() (أي خطأ) {
    العودة "default", nl
})
```

### استرداد و حذف

```go
القيمة := facades.Cache().Pull("goravel", "الافتراضي")
```

### تخزين العناصر في ذاكرة التخزين المؤقت

```go
err := facades.Cache().Put("goravel", "value", 5*time.Second)
```

إذا تم تعيين وقت انتهاء صلاحية ذاكرة التخزين المؤقت إلى '0\`، فإن ذاكرة التخزين المؤقت ستكون صالحة إلى الأبد:

```go
err := facades.Cache().Put("goravel", "value", 0)
```

### المتجر إذا لم يكن حاضراً

طريقة "إضافة" تخزن البيانات فقط إذا لم تكن في ذاكرة التخزين المؤقت. إنها ترجع 'true' إذا كان التخزين ناجحا و 'false' إذا كان
ليس كذلك.

```go
bool := facades.Cache().Add("goravel", "value", 5*time.Second)
```

### تخزين العناصر إلى الأبد

ويمكن استخدام طريقة "إلى الأبد" لتخزين البيانات باستمرار في ذاكرة التخزين المؤقت. Because these data will not expire, they must
be manually deleted from the cache through the `Forget` method:

```go
bool := facades.Cache().Forever("goravel", "value")
```

### إزالة العناصر من ذاكرة التخزين المؤقت

```go
bool := facades.Cache().Forget("goravel")
```

يمكنك استخدام طريقة "Flush" لمسح جميع المخبآت:

```go
bool := facades.Cache().Flush()
```

## برنامج القفل

### إدارة الأقفال

وتسمح الأقفال الذرية بالتلاعب بالقفل الموزعة دون القلق بشأن ظروف العرق. يمكنك إنشاء و
إدارة الأقفال باستخدام طريقة `قفل`:

```go
قفل := facades.Cache().Lock("foo", 10*time.Second)

إذا (lock.Get()) {
    // / قفل تم الحصول عليه لمدة 10 ثوان...

    lock.Release()
}
```

كما أن طريقة "Get" تقبل الإغلاق. بعد تنفيذ الإغلاق، ستطلق غورافيل تلقائيًا القفل:

```go
facades.Cache().Lock("foo").Get(func () {
    // Lock تم الحصول عليها لمدة 10 ثوان وتم إصدارها تلقائياً...
})؛
```

إذا لم يكن القفل متاحاً في الوقت الذي تطلبه، فيمكنك أن توعز إلى غورفيل بالانتظار لعدد محدد من
ثواني. إذا لم يكن من الممكن الحصول على القفل في غضون المهلة الزمنية المحددة، فسيعود `خطأ`:

```go
قفل := facades.Cache().Lock ("foo", 10*time.Second)
// قفل تم الحصول عليه بعد الانتظار 5 ثوان كحد أقصى...
اذا (lock.Block(5*time.Second)) {
    lock.Release()
}
```

يمكن تبسيط المثال أعلاه بنقل إغلاق إلى طريقة "البلوك". وعندما يتم إقفال هذا الطريقة،
Goravel سيحاول الحصول على القفل لعدد محدد من الثواني وسيطلق تلقائياً القفل
بمجرد تنفيذ الإغلاق:

```go
facades.Cache().Lock("foo", 10*time.Second).Block(5*time.II, func () {
    // Lock تم الحصول عليها بعد الانتظار بحد أقصى 5 ثوان...
})
```

إذا كنت ترغب في الإفراج عن قفل دون احترام مالكه الحالي، فيمكنك استخدام طريقة "إطلاق القوة":

```go
facades.Cache().Lock("التجهيز").ForceRelease();
```

## إضافة مشغلات ذاكرة التخزين المؤقت المخصصة

### الإعدادات

إذا كنت ترغب في تعريف مشغل مخصص بالكامل، يمكنك تحديد نوع مشغل 'custom' في ملف 'config/cache.go'
تكوين.
ثم يشمل خيارا 'via\` لتنفيذ واجهة 'framework/contracts/cache/river':

```go
/config/cache. o
"stores": map[string]interface{}{
    "memory": map[string]any{
        "المشغل": "memory",
    }،
    "مخصص": خريطة[string]واجهة{}{
        "السائق": "مخصص"،
        "بواسطة": &Logger{},
    },
},
```

### تنفيذ مشغل مخصص

تنفيذ واجهة 'framework/contracts/cache/Driver' ، يمكن تخزين الملفات في مجلد 'app/extensions' (
معدل).

```go
// framework/contracts/cache/مشغل
حزمة ذاكرة التخزين المؤقت

استيراد "time"

نوع واجهة المشغل {
    // إضافة عنصر في ذاكرة التخزين المؤقت إذا كان المفتاح غير موجود.
    إضافة (سلسلة المفتاح, قيمة أي وقت. uration) المرسوم
    (سلسلة مفتاحية، قيمة... nt) (int, خطأ)
    // إلى الأبد مشغل عنصر في ذاكرة التخزين المؤقت إلى أجل غير مسمى.
    إلى الأبد (سلسلة المفتاح، أي قيمة) bool
    // نسيت إزالة عنصر من ذاكرة التخزين المؤقت.
    نسيت (سلسلة المفتاح) bool
    // Flush إزالة جميع العناصر من ذاكرة التخزين المؤقت.
    Flush() bool
    // احصل على استرداد عنصر من ذاكرة التخزين المؤقت عن طريق المفتاح.
    Get(سلسلة أساسية، def . .any) أي
    GetBool(سلسلة المفتاح, def ...bool) bool
    GetInt(سلسلة المفتاح, def ... nt) int
    GetInt64(سلسلة مفتاحية، def ...int64) int64
    GetString(سلسلة مفتاحية، def ... محاولة) سلسلة
    // تحقق من عنصر موجود في ذاكرة التخزين المؤقت.
    سلسلة (سلسلة مفتاحية)
    زيادة (سلسلة مفتاحية، قيمة. .int) (int, error)
    قفل (المفتاح, t ...time. uration) قفل
    // ضع مشغل عنصر في ذاكرة التخزين المؤقت لفترة معينة.
    القطع (سلسلة المفتاح، أي قيمة ، الوقت . ury) خطأ
    // اسحب عنصر من ذاكرة التخزين المؤقت وحذفه.
    سحب (سلسلة المفتاح, def... لا ) أي
    // تذكر الحصول على عنصر من ذاكرة التخزين المؤقت، أو تنفيذ الإغلاق المحدد وتخزين النتيجة.
    تذكر(سلسلة المفتاح, وقت الحدث. ure, reback func() (أي خطأ)) (أي خطأ)
    // RememberForever احصل على عنصر من ذاكرة التخزين المؤقت، أو تنفيذ الإغلاق المعطى وتخزين النتيجة إلى الأبد.
    RememberForever(المفتاح، وظيفة رد المكالمة () (أي خطأ)) (أي خطأ)
    WithContext(ctx context.Context) Driver
}
```
