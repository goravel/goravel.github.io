# العلاقات

من الشائع أن تكون جداول قواعد البيانات مترابطة. على سبيل المثال، قد تحتوي مشاركة المدونة على العديد من التعليقات، أو قد يكون الطلب
مرتبطا بالمستخدم الذي قام بوضعه. 'Orm' يبسط إدارة هذه العلاقات والتعامل معها، ويمكنه التعامل مع
مختلف العلاقات المشتركة:

- [واحد إلى واحد](#one-to-one)
- [واحد لكثير منها](#one-to-many)
- [كثيرًا لكثير] (#Many-To-Many)
- [Polymorphic](#polymorphic)

## تعريف العلاقات

### واحد إلى واحد

فالعلاقة بين شخص وآخر هي نوع أساسي جدا من علاقات قاعدة البيانات. على سبيل المثال، يمكن ربط نموذج "المستخدم"
مع نموذج "الهاتف".

```go
اكتب بنية المستخدم {
  orm. Odel
  اسم السلسلة
  الهاتف *


نوع الهاتف الذي تم تركيبه {
  orm. Odel
  UserID uint
  سلسلة الاسم
}
```

وعند استخدام \`Orm'، يقوم تلقائياً بتعيين المفتاح الأجنبي للعلاقة استناداً إلى اسم النموذج الأصلي. على سبيل المثال
يفترض أن نموذج 'Phone' يحتوي على مفتاح 'UserID' أجنبي افتراضيا. ومع ذلك، إذا كنت ترغب في تغيير هذه الاتفاقية
، فيمكنك إضافة علامة "مفاتيح أجنبية" إلى حقل "الهاتف" في نموذج "المستخدم". (وهذا ينطبق أيضا على علاقات
الأخرى.)

```go
اكتب بنية المستخدم {
  orm. Odel
  اسم السلسلة
  الهاتف *`gorm:"foreignKey:UserName"`


نوع بنية الهاتف {
  orm. Odel
  سلسلة اسم المستخدم
  سلسلة الاسم
}
```

وبالإضافة إلى ذلك، يُفترض عند استخدام 'الترتيب` أن يتطابق المفتاح الأجنبي مع العمود الرئيسي الرئيسي للأب.
وهذا يعني أن 'Orm' سوف يبحث عن قيمة عمود 'ID' المستخدم في عمود 'UserId' من سجل 'الهاتف'. إذا كنت
ترغب في استخدام قيمة رئيسية أخرى غير 'ID`، يمكنك إضافة إشارة "علامة" إلى حقل "الهاتف" في نموذج "المستخدم". إلى
قم بذلك، ببساطة نقل حجة ثالثة إلى طريقة 'hasOne'. (إعداد العلاقات متشابه.)

```go
اكتب بنية المستخدم {
  orm. Odel
  اسم السلسلة
  الهاتف *`gorm:"foreignKey:UserName; تفضيلات:name"`


نوع بنية الهاتف {
  عال. Odel
  سلسلة اسم المستخدم
  سلسلة الاسم
}
```

#### تعريف عكس العلاقة

يمكننا الوصول إلى نموذج "الهاتف" من نموذج "المستخدم". Now, we need to establish a relationship on `Phone` model that
allows us to access the phone's owner. للقيام بذلك، يمكننا تحديد حقل "المستخدم" في نموذج "الهاتف".

```go
اكتب بنية المستخدم {
  orm.Model
  اسم السلسلة


نوع الهاتف بنى {
  orm. odel
  UserID uint
  name string
  user *user
}
```

### واحد للكثيرين

يتم استخدام علاقة واحدة إلى متعددة لتحديد العلاقات التي يكون فيها الموديل الواحد هو الوالد لواحد أو أكثر من نماذج الأطفال
. على سبيل المثال ، قد تحتوي مشاركة المدونة على عدد غير محدود من التعليقات. مثل جميع العلاقات الأخرى 'Orm'، يتم تعريف
علاقات واحدة إلى كثيرة من خلال تعريف حقل على نموذج 'Orm' الخاص بك:

```go
نوع بنية المشاركة {
  عوام. odel
  اسم سلسلة
  تعليقات []*تعليق


نوع تعليق بنت {
  عال. Odel
  PostID uint
  سلسلة الاسم
}
```

تذكر أن "Orm" سيحدد تلقائياً العمود المفتاح الأجنبي المناسب لنموذج "التعليق". حسب العرف، سيأخذ Orm
اسم "حالة الحدث" للنموذج الأصلي ويتلقيه مع `ID`. لذلك، في هذا المثال، سيفترض Orm عمود المفتاح
الأجنبي في نموذج "التعليق" هو "PostID".

### واحد للكثيرين (معكوس) / ينتمي إلى

الآن بعد أن يمكننا الوصول إلى جميع تعليقات المشاركة، دعونا نحدد علاقة للسماح للتعليق بالوصول إلى منشوره الأصلي
. لتعريف العلاقة العكسية 'واحد إلى كثير\`، تعريف طريقة العلاقة على نموذج الطفل التي تسمى
طريقة 'belongsto':

```go
نوع بنية المشاركة {
  عوام. odel
  اسم سلسلة
  تعليقات []*تعليق


نوع تعليق بنت {
  عال. odel
  PostID uint
  سلسلة الاسم
  Pos*Post
}
```

## العديد من العلاقات

والعديد من العلاقات بين العديد منها أكثر تعقيدا بقليل من علاقات 'الواحد إلى الواحد` و 'الواحد إلى الكثير`. مثال على علاقة
بين عدة مرات والعديد هو المستخدم الذي له أدوار كثيرة وهذه الأدوار يشترك فيها أيضا مستخدمون آخرون في التطبيق
. على سبيل المثال، يمكن إسناد دور "المؤلف" و"المحرر"؛ ومع ذلك، قد تكون هذه الأدوار أيضًا
مخصصة لمستخدمين آخرين أيضًا. لذلك فإن المستخدم له العديد من الأدوار والدور لديه العديد من المستخدمين.

### هيكل الجدول

ولتحديد هذه العلاقة، هناك حاجة إلى ثلاثة جداول لقواعد البيانات: 'المستخدمون`، 'الدور`، و 'الدورة_user\`. يمكن تخصيص جدول 'role_user'
اسم ويحتوي على عمود 'user_id' و 'role_id'. يستخدم هذا الجدول كجدول وسيط
يربط المستخدمين والأدوار.

تذكر، بما أن الدور يمكن أن ينتمي إلى العديد من المستخدمين، لا يمكننا ببساطة وضع عمود "user_id" على جدول "الأدوار". سيعني هذا
أن الدور لا يمكن أن ينتمي إلا لمستخدم واحد. من أجل توفير الدعم للأدوار التي يتم تعيينها لـ
مستخدمين متعددين، هناك حاجة إلى جدول 'role_user'. يمكننا تلخيص هيكل جدول العلاقة مثل هذا:

```
المستخدمون
  معرف - عدد صحيح
  اسم - السلسلة

أدوار
  معرف - عدد صحيح
  اسم - السلسلة

دور_user
  user_id - عدد صحيح
  role_id - عدد صحيح
```

### بنية النموذج

يمكننا تعريف حقل "Roles" على نموذج "المستخدم":

```go
اكتب بنية المستخدم {
  orm. odel
  اسم سلسلة
  أدوار []*دور `gorm:"many2many:role_user"`


نوع الدور الذي تم تركيبه {
  orm. Odel
  سلسلة الاسم
}
```

### تعريف عكس العلاقة

لتعريف عكس العلاقة، فقط تعريف حقل "المستخدمين" في نموذج "الدور" وإلحاق علامة.

```go
اكتب بنية المستخدم {
  orm. odel
  اسم سلسلة
  أدوار []*دور `gorm:"many2many:role_user"`


نوع الدور الذي تم تركيبه {
  orm. odel
  اسم السلسلة
  المستخدمين []*المستخدم `gorm:"many2many:role_user"`
}
```

### جدول وسيط مخصص

وعموما، فإن المفتاح الأجنبي للطاولة الوسيطة تسمى ب "قضية الثعب" من اسم النموذج الأم، يمكنك تجاوزها
بواسطة `joinForeignKey`, `joinReferences`:

```go
اكتب بنية المستخدم {
  orm. Odel
  اسم سلسلة
  أدوار []*دور `gorm:"many2many:role_use; oinForeignKey:UserName;joinReferences:RoleName"`


نوع الدور المبنى {
  orm. Odel
  سلسلة الاسم
}
```

بنية الجدول:

```
المستخدمون
  معرف - عدد صحيح
  اسم - السلسلة

أدوار
  معرف - عدد صحيح
  اسم - السلسلة

دور_user
  user_name - عدد صحيح
  role_name - عدد صحيح
```

## البوليمورفيك

وتسمح العلاقة المتعددة المورفين بأن يكون نموذج الطفل منتمياً إلى أكثر من نوع واحد باستخدام جمعية واحدة.
على سبيل المثال، تخيل أنك تقوم ببناء تطبيق يسمح للمستخدمين بمشاركة مشاركات المدونة ومقاطع الفيديو. في مثل هذا التطبيق
قد ينتمي نموذج 'تعليق\` إلى كل من نموذجي 'Post' و 'Video'.

### بنية الجدول

أي علاقة متعدّدة المورفينات مماثلة للعلاقة العادية؛ على كل حال يمكن أن ينتمي نموذج الطفل إلى أكثر من نوع
باستخدام جمعية واحدة. على سبيل المثال، المدونة "Post" و "المستخدم" يمكن أن يتشاركا علاقة متعددة المورفين مع نموذج "صورة"
. يتيح لك استخدام علاقة متعددة المورفين الحصول على جدول واحد للصور الفريدة التي قد تكون مرتبطة بالمشاركات
والمستخدمين. أولا، دعونا نفحص بنية الجدول:

```
المنشورات
  معرف - عدد صحيح
  اسم - السلسلة

الفيديوهات
  معرف - عدد صحيح
  اسم - السلسلة

صور
  معرف - عدد صحيح
  رابط - السلسلة
  imageable_id - عدد صحيح
  image_type - السلسلة

تعليقات
  معرف - عدد صحيح
  - النص
  Comtable_id - عدد صحيح
  commentable_type - السلسلة
```

لاحظ عمودي `imageable_id` و `imageable_type` على جدول `الصور`. العمود \`imageable_id' سوف يحتوي على قيمة
ID للمنشور أو المستخدم، في حين أن العمود 'imageable_type' سيحتوي على اسم الفئة من النموذج الأصلي. يتم استخدام عمود
'imageable_type' من قبل Orm لتحديد أي "نوع" من النموذج الأصلي الذي سيتم إرجاعه عند الوصول إلى العلاقة
'image'. والجدول المعنون ”التعليقات“ متشابه.

### بنية النموذج

وبعد ذلك، دعونا ندرس التعاريف النموذجية اللازمة لبناء هذه العلاقة:

```go
نوع بنية المشاركة {
  عوام. odel
  اسم السلسلة
  صورة *صورة `gorm:"polyorphic:Imageable"`
  تعليقات []*تعليق `gorm:"polyorphic:Commentable"` `
}

من نوع الفيديو }
  orm. odel
  اسم السلسلة
  صورة *صورة `gorm:"polyorphic:Imageable"`
  تعليقات []*تعليق `gorm:"polyorphic:Commentable"`


نوع الصورة التي تم تركيبها {
  orm. odel
  اسم السلسلة
  ImageableID uint
  ImageableType string


نوع التعليق {
  orm. odel
  اسم السلسلة
  CommentableID uint
  CommentableType string
}
```

يمكنك تغيير القيمة المتعددة الوسائط عن طريق وسم \`polyorphicValue'، مثل:

```go
نوع بنية المشاركة {
  orm.Model
  اسم سلسلة
  صورة *صورة `gorm:"polymorphic:Imageable;polyorphicValue:master"`
}
```

## جمعيات الاستعلام

على سبيل المثال، تخيل تطبيق مدونة يحتوي نموذج "المستخدم" على العديد من نماذج "Post" المرتبطة:

```go
اكتب بنية المستخدم {
  orm. odel
  اسم السلسلة
  المشاركات []*Post


نوع بنية المشاركة {
  orm. Odel
  UserID uint
  سلسلة الاسم
}
```

### إنشاء أو تحديث الجمعيات

يمكنك استخدام طرق "Select" و "Omit" للتحكم في إنشاء الجمعيات وتحديثها. لا يمكن أن تكون هاتان الطريقتان
مستخدمتين في نفس الوقت ووظائف التحكم المرتبطة بهما تنطبق فقط على 'إنشاء` و 'تحديث` و 'حفظ\`:

```go
المستخدم := models.User{Name: "user", Posts: []*models.Post{{Name: "post"}}}

// إنشاء جميع جمعيات الأطفال أثناء إنشاء واجهات المستخدم
. rm().Query().Select(orm.Associations).Create(&user)

// إنشاء مشاركة فقط أثناء إنشاء المستخدم. ملاحظة: إذا كنت لا تستخدم 'orm.Associations'، ولكن قم بتكييف جمعيات أطفال محددة بشكل منفصل، فيجب أيضا إدراج جميع الحقول في النموذج الأصل في هذا الوقت.
facades.Orm().Query().Select("Name", "Posts"). reate(&user)

// عند إنشاء مستخدم، تجاهل المنشور، ولكن أنشئ جميع جمعيات الأطفال الأخرى
facades.Orm().Query. mit("Posts").Create(&user)

// عند إنشاء المستخدم، تجاهل حقل الاسم، ولكن إنشاء جميع جمعيات الأطفال
واجهة. rm().Query().Omit("Name").Create(&user)

// عند إنشاء المستخدم، تجاهل حقل الاسم وجميع جمعيات الأطفال
facades.Orm().Query().Omit("Name", orm.Associations).Create(&user)
```

### البحث عن الجمعيات

```go
// العثور على جميع السجلات المطابقة ذات الصلة
var posts []models.Post
facades.Orm().Query().Model(&user).Association("Posts").Find(&posts)

// العثور على روابط مع الشروط
facades.Orm().Query().Model(&user).here("name = ?", "goravel").Order("id desc").Association("Posts").Find(&posts)
```

### إلحاق الجمعيات

Append new associations for `Many To Many`, `One To Many`, replace current association for `One To One`,
`One To One(revers)`:

```go
facades.Orm().Query().Model(&user).Association("Posts").Append([]*models.Post{Post1, Post2})

facades.Orm().Query().Model(&user).Association("Posts").Append(&models.Post{Name: "goravel"})
```

### استبدال الجمعيات

يستعاض عن الروابط الحالية بالرابطات الجديدة:

```go
facades.Orm().Query().Model(&user).Association("Posts").Replace([]*models.Post{Post1, Post2}

facades.Orm().Query().Model(&user).Association("Posts").Replace(models.Post{Name: "goravel"}, Post2)
```

### حذف الجمعيات

إزالة العلاقة بين المصدر والحجج إن وجدت، فقط حذف المرجع، لن يحذف هذه الكائنات من
DB، المفتاح الأجنبي يجب أن يكون NUL:

```go
facades.Orm().Query().Model(&user).Association("Posts").Delete([]*models.Post{Post1, Post2})

facades.Orm().Query().Model(&user).Association("Posts").delete(Post1, Post2,
```

### تنظيف الروابط

إزالة جميع المراجع بين المصدر والرابطة، لن تحذف هذه الرابطات:

```go
facades.Orm().Query().Model(&user).Association("Posts").Clear()
```

### عدد الجمعيات

إرجاع عدد الجمعيات الحالية:

```go
facades.Orm().Query().Model(&user).Association("Posts").Count()

// Count مع الشروط
facades.Orm().Query().Model(&user).here("name = ?", "goravel").Association("Posts").Count()
```

### دفعة البيانات

```go
// العثور على جميع الأدوار لجميع المستخدمين
facades.Orm().Query().Model(&users).Association("Posts").Find(&posts)

// حذف المستخدم A من جميع واجهات المستخدم
. rm().Query().Model(&users).Association("Posts").delete(&userA)

// الحصول على عدد متميز من جميع مشاركات المستخدمين
. rm().Query().Model(&users).Association("Posts"). ount()

/ / مقابل 'Append`، 'استبدال' ببيانات الدفعة، يجب أن يكون طول الحجج مساوياً لطول البيانات أو أنه سيؤدي إلى إرجاع خطأ
var مستخدمين = []models. انظر{user1, user2, user3}

// لدينا 3 مستخدمين، إلحاق المستخدم A بفريق المستخدم، إلحاق المستخدم B لفريق المستخدم،إلحاق المستخدم A و المستخدم B و المستخدم C بواجهات المستخدم 3
. rm().Query().Model(&users).Association("Team").Append(&userA, &userB, &[]models. انظر{userA, userB, userC})

// إعادة تعيين المستخدم 1 إلى المستخدم A، إعادة تعيين فريق المستخدم 2 إلى المستخدم، إعادة تعيين فريق المستخدم 3 إلى المستخدم A، المستخدم B و المستخدم C
. rm().Query().Model(&users).Association("فريق").Replace(&userA, &userB, &[]models.user{userA, userB, userC})
```

## تحميل النسر

تسهيلات تحميل Eager للاستعلام عن نماذج متعددة، وتخفيف مشكلة الاستعلام "N + 1". لتوضيح مشكلة الاستفسار N +
1، فكر في نموذج 'كتاب` الذي "ينتمي إلى" نموذج 'مؤلف`:

```go
اكتب المؤلف بنيت {
  orm.Model
  اسم السلسلة
A}

نوع هيكل الكتاب {
  orm. odel
  AuthorID uint
  name string
  المؤلف *
}
```

الآن، دعونا نسترد كل الكتب ومؤلفها:

```go
قم بتغيير نماذج الكتب. الكتاب
facades.Orm().Query().Find(&books)

ل _، الكتاب := كتب النطاق {
  var boomodels.Author
  facades.Orm().Query().Find(&author, book.AuthorID)
}
```

لاسترداد جميع الكتب في جدول قاعدة البيانات مع مؤلفيها، يقوم رمز الحلقة بتنفيذ استعلام لكل كتاب.
وهذا يعني أنه بالنسبة لمجموعة مؤلفة من 25 كتابا، ستستخدم الحلقة 26 استفسارا - واحد لمجموعة الكتب و 25
أكثر للحصول على مؤلف كل كتاب.

ومع ذلك، يمكننا تبسيط هذه العملية باستخدام التحميل الحريص. من خلال استخدام طريقة 'with' ، يمكننا تحديد أي علاقات
تحتاج إلى أن يتم تحميلها بشغف وتقليل عدد الاستفسارات إلى اثنين فقط.

```go
قم بتغيير نماذج الكتب. الكتاب
facades.Orm().Query().With("Author").Find(&books)

مقابل _، الكتاب := مجموعة الكتب {
  fmt.Println(book.Author)
}
```

لهذه العملية، سيتم تنفيذ استفسارين فقط - استفسار واحد لاسترجاع جميع الكتب واستفسار واحد لاسترجاع
للمؤلفين لكل الكتاب:

```sql
اختر * من `الكتاب';

اختر * من `authors' where `id' in (1, 2, 3, 4, 5, ...);
```

### تحميل النسر العلاقات المتعددة

في بعض الأحيان قد تحتاج إلى التيقظ لتحميل عدة علاقات مختلفة. To do so, just call the `With` method multiple
times:

```go
نماذج كتاب الكتب. الكتاب
facades.Orm().Query().With("Author").With("الناشر").Find(&book)
```

### تحميل النسر المتداخلة

لحرص على تحميل علاقات العلاقة، يمكنك استخدام بناء الجملة "dot". على سبيل المثال، دعونا نحرص على تحميل جميع مؤلفي الكتاب
وجميع جهات الاتصال الشخصية للمؤلف:

```go
نماذج كتاب الكتب. الكتاب
facades.Orm().Query().With("Author.Contacts").Find(&book)
```

### تقييد حمولة النسر

في بعض الأحيان قد ترغب في توق لتحميل علاقة ولكن أيضا تحديد شروط استعلام إضافية للتحميل المتحرك
الاستعلام. يمكنك إنجاز ذلك على النحو التالي:

```go
استيراد "github.com/goravel/framework/contracts/database/orm"

var book models.Book
facades.Orm().Query().With("Author", "name = ?", "author"). ind(&book)

facades.Orm().Query().With("Author", function(Query orm.Query) orm.Query {
  return query.Where("name = ?", "author")
}).Find(&book)
```

في هذا المثال ، لن تتوق شركة Orm إلا إلى تحميل المشاركات حيث يكون عمود "name" للوظيفة مساويا لكلمة `author`.

### تحميل النسر اللاحق

قد تحتاج في بعض الأحيان إلى توق لتحميل علاقة بعد استرداد النموذج الأصل مسبقاً. على سبيل المثال، قد يكون هذا
مفيداً إذا كنت بحاجة إلى أن تقرر ديناميكياً ما إذا كنت تريد تحميل النماذج ذات الصلة:

```go
قم بتغيير نماذج الكتب. الكتاب
facades.Orm().Query. ind(&books)

مقابل _، الكتاب := نطاقات الكتب {
  إذا كان هناك شرط ما {
    الخطأ := واجهة. rm().Query().Load(&book, "المؤلف")
  }
}
```

إذا كنت بحاجة إلى تعيين قيود استعلام إضافية على استعلام التحميل، يمكنك استخدام التعليمات البرمجية أدناه:

```go
استيراد "github.com/goravel/framework/contracts/database/orm"

var book models.Book
facades.Orm().Query().Load(&book, "Author", "name = ?", "author"). ind(&book)

facades.Orm().Query().Load(&book، "المؤلف"، وظيفة (الاستفسار orm.Query) orm.Query {
  return query.Where("name = ?", "author")
}).Find(&book)
```

لتحميل علاقة فقط عندما لا يكون قد تم تحميلها، استخدم طريقة "تحميل مفقود":

```go
facades.Orm().Query().LoadMissing(&book, "المؤلف")
```
